#q=1


data <- sapply(seq(0, 60, 6), function(mu) rnorm(20, mu))
mixing <- matrix(1/10, nrow = 10)
  
  
dens<-function(q)
{
  
  probs <- sapply(q, function(mu) dnorm(data, mu))
  sum(probs %*% mixing)
}

U = function(q){
  return(-log(dens(q)))
}



gradU<-function(q,U)
{
  h<-.000000001
  for(i in 1)
    gradg<-(U(q+h)-U(q-h))/(2*h)
}

HMC=function(U2,eps,L,currq)
{
  q=currq
  p=rnorm(length(q),0,1)
  currp=p
  
  p=p-eps*gradient(U2,q,centered = TRUE,pert=1*10^-8)/2
  
  for(i in 1:L)
  {
    q=q+eps*p
    
    if(i!=L)
    {
      p=p-eps*gradient(U2,q,centered = TRUE,pert = 1*10^-8)
    }
    
  }
  p=p-eps*gradient(U2,q,centered = TRUE,pert=1*10^-8)/2
  
  p=-p
  
  currU=U2(currq)
  currK=sum(currp^2)/2
  propU=U2(q)
  propK=sum(p^2)/2
  
  if(runif(1)<exp(currU-propU+currK-propK))
  {
    return(q)
  }
  else
  {
    return(currq)
  }
  
}

iters = 10000
D = 10

qtracker <- matrix(NA, iters, D)
qtracker[1,]<- rep(0, D)
for(i in 2:iters)
{
  qtracker[i,]<-HMC(U,.2,20,qtracker[i-1,])
}


